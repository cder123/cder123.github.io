---
title: 功能实现方案
tag: Java
categories:
  - [Java,业务功能]
---



<h1>功能实现方案</h1>

[toc]



# 0、资料



>  
>
> 订单相关：
>
> - [订单系统的设计](https://mp.weixin.qq.com/s/kCVNlxsLsEba3tcdAJliZg)
> - [订单30分钟取消功能](https://mp.weixin.qq.com/s/D5B1ZNAaSItW2xE1iWwEPg)
> - [防止重复支付](https://mp.weixin.qq.com/s/7JdYEh57eRUZqKZ7yucseg)
> - [防止重复下单](https://mp.weixin.qq.com/s/Dc_4taB6Boojdw_0mngroQ)
>
> - [抢红包系统](https://mp.weixin.qq.com/s/fhoSrVYppuTHNKUoQhwTEQ)
> - [支付功能](https://mp.weixin.qq.com/s/uzR4ZbAomfY-J3iEvCirQA)
> - [优惠券设计](https://mp.weixin.qq.com/s/C7bzN2mkePqgR2W55FnXAQ)
> - [秒杀](https://mp.weixin.qq.com/s/4iHKNVl14UAuNXGyBTbjWA)
>
> 
>
> 限流相关：
>
> - [不雅词过滤](https://mp.weixin.qq.com/s/KS_mlf6FeKKgRwgzmLpBIg)
>
> - [接口限流](https://mp.weixin.qq.com/s/ozRK-VotbkR2LQ3u0atHLw)
> - [Redis限流](https://mp.weixin.qq.com/s/cdBj94N5NYKRXj4zj3cW8g)
>
>  
>
> 其他：
>
> - [任务调度](https://mp.weixin.qq.com/s/eY0M4IHN9yfmvCXxBu_H_Q)
> - [文件断点续传](https://mp.weixin.qq.com/s/NvMe0ybF1TR_w7oKPEOWrg)
> - [权限控制](https://mp.weixin.qq.com/s/rVIORr09VCXiAFKh92r8Tw)
> - [消息推送](https://mp.weixin.qq.com/s/_3uGLngOab7NDtUmNCVXgw)
> - [消息推送](https://mp.weixin.qq.com/s/Zmoc8HY0TRVUDbERSeu2Mw)
> - [IP归属地](https://mp.weixin.qq.com/s/yp6_n1Pn1-hP2_nv3InC1Q)
> - [短链生成](https://mp.weixin.qq.com/s/e7EuYLdlO5nRoLcf0pFOrA)









# 1、热搜+不雅词过滤



**使用java和redis实现一个简单的热搜功能，具备以下功能：**

1. 搜索栏展示当前登陆的个人用户的搜索历史记录，删除个人历史记录
2. 用户在搜索栏输入某字符，则将该字符记录下来 以zset格式存储的redis中，记录该字符被搜索的个数以及当前的时间戳 （用了DFA算法，感兴趣的自己百度学习吧）
3. 每当用户查询了已在redis存在了的字符时，则直接累加个数， 用来获取平台上最热查询的十条数据。（可以自己写接口或者直接在redis中添加一些预备好的关键词）
4. 最后还要做不雅文字过滤功能。这个很重要不说了你懂的。

**代码实现热搜与个人搜索记录功能，主要controller层下几个方法就行了 ：**

1. 向redis 添加热搜词汇(添加的时候使用下面不雅文字过滤的方法来过滤下这个词汇，合法再去存储
2. 每次点击给相关词热度 +1
3. 根据key搜索相关最热的前十名
4. 插入个人搜索记录
5. 查询个人搜索记录



## 1.1、核心代码



```java
import com.jianlet.service.user.RedisService;
import org.apache.commons.lang.StringUtils;
import org.springframework.data.redis.core.*;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;
import java.util.*;
import java.util.concurrent.TimeUnit;
 

@Transactional
@Service("redisService")
public class RedisServiceImpl implements RedisService {
 
    //导入数据源
    @Resource(name = "redisSearchTemplate")
    private StringRedisTemplate redisSearchTemplate;
 
 
    //新增一条该userid用户在搜索栏的历史记录
    //searchkey 代表输入的关键词
    @Override
    public int addSearchHistoryByUserId(String userid, String searchkey) {
        String shistory = RedisKeyUtils.getSearchHistoryKey(userid);
        boolean b = redisSearchTemplate.hasKey(shistory);
        if (b) {
            Object hk = redisSearchTemplate.opsForHash().get(shistory, searchkey);
            if (hk != null) {
                return 1;
            }else{
                redisSearchTemplate.opsForHash().put(shistory, searchkey, "1");
            }
        }else{
            redisSearchTemplate.opsForHash().put(shistory, searchkey, "1");
        }
        return 1;
    }
 
    //删除个人历史数据
    @Override
    public Long delSearchHistoryByUserId(String userid, String searchkey) {
        String shistory = RedisKeyUtils.getSearchHistoryKey(userid);
        return redisSearchTemplate.opsForHash().delete(shistory, searchkey);
    }
 
    //获取个人历史数据列表
    @Override
    public List<String> getSearchHistoryByUserId(String userid) {
        List<String> stringList = null;
        String shistory = RedisKeyUtils.getSearchHistoryKey(userid);
        boolean b = redisSearchTemplate.hasKey(shistory);
        if(b){
            Cursor<Map.Entry<Object, Object>> cursor = redisSearchTemplate.opsForHash().scan(shistory, ScanOptions.NONE);
            while (cursor.hasNext()) {
                Map.Entry<Object, Object> map = cursor.next();
                String key = map.getKey().toString();
                stringList.add(key);
            }
            return stringList;
        }
        return null;
    }
 
    //新增一条热词搜索记录，将用户输入的热词存储下来
    @Override
    public int incrementScoreByUserId(String searchkey) {
        Long now = System.currentTimeMillis();
        ZSetOperations zSetOperations = redisSearchTemplate.opsForZSet();
        ValueOperations<String, String> valueOperations = redisSearchTemplate.opsForValue();
        List<String> title = new ArrayList<>();
        title.add(searchkey);
        for (int i = 0, lengh = title.size(); i < lengh; i++) {
            String tle = title.get(i);
            try {
                if (zSetOperations.score("title", tle) <= 0) {
                    zSetOperations.add("title", tle, 0);
                    valueOperations.set(tle, String.valueOf(now));
                }
            } catch (Exception e) {
                zSetOperations.add("title", tle, 0);
                valueOperations.set(tle, String.valueOf(now));
            }
        }
        return 1;
    }
    
    //根据searchkey搜索其相关最热的前十名 (如果searchkey为null空，则返回redis存储的前十最热词条)
    @Override
    public List<String> getHotList(String searchkey) {
        String key = searchkey;
        Long now = System.currentTimeMillis();
        List<String> result = new ArrayList<>();
        ZSetOperations zSetOperations = redisSearchTemplate.opsForZSet();
        ValueOperations<String, String> valueOperations = redisSearchTemplate.opsForValue();
        Set<String> value = zSetOperations.reverseRangeByScore("title", 0, Double.MAX_VALUE);
        //key不为空的时候 推荐相关的最热前十名
        if(StringUtils.isNotEmpty(searchkey)){
            for (String val : value) {
                if (StringUtils.containsIgnoreCase(val, key)) {
                    if (result.size() > 9) {//只返回最热的前十名
                        break;
                    }
                    Long time = Long.valueOf(valueOperations.get(val));
                    if ((now - time) < 2592000000L) {//返回最近一个月的数据
                        result.add(val);
                    } else {//时间超过一个月没搜索就把这个词热度归0
                        zSetOperations.add("title", val, 0);
                    }
                }
            }
        }else{
            for (String val : value) {
                if (result.size() > 9) {//只返回最热的前十名
                    break;
                }
                Long time = Long.valueOf(valueOperations.get(val));
                if ((now - time) < 2592000000L) {//返回最近一个月的数据
                    result.add(val);
                } else {//时间超过一个月没搜索就把这个词热度归0
                    zSetOperations.add("title", val, 0);
                }
            }
        }
        return result;
    }
 
    //每次点击给相关词searchkey热度 +1
    @Override
    public int incrementScore(String searchkey) {
        String key = searchkey;
        Long now = System.currentTimeMillis();
        ZSetOperations zSetOperations = redisSearchTemplate.opsForZSet();
        ValueOperations<String, String> valueOperations = redisSearchTemplate.opsForValue();
        zSetOperations.incrementScore("title", key, 1);
        valueOperations.getAndSet(key, String.valueOf(now));
        return 1;
    } 
 
}
```



## 1.2、配置类



在配置类中，读取`Resource/static/censorword.txt`敏感词文件。

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import java.io.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
 
 
//屏蔽敏感词初始化
@Configuration
@SuppressWarnings({ "rawtypes", "unchecked" })
public class SensitiveWordInit {
    // 字符编码
    private String ENCODING = "UTF-8";
    // 初始化敏感字库
    public Map initKeyWord() throws IOException {
        // 读取敏感词库 ,存入Set中
        Set<String> wordSet = readSensitiveWordFile();
        // 将敏感词库加入到HashMap中//确定有穷自动机DFA
        return addSensitiveWordToHashMap(wordSet);
    }
 
    // 读取敏感词库 ,存入HashMap中
    private Set<String> readSensitiveWordFile() throws IOException {
    Set<String> wordSet = null;
        // 读取敏感词文件
        ClassPathResource classPathResource = new ClassPathResource("static/censorword.txt");
        InputStream inputStream = classPathResource.getInputStream();
        //敏感词库
        try {
        // 读取文件输入流
            InputStreamReader read = new InputStreamReader(inputStream, ENCODING);
            // 文件是否是文件 和 是否存在
            wordSet = new HashSet<String>();
            // StringBuffer sb = new StringBuffer();
            // BufferedReader是包装类，先把字符读到缓存里，到缓存满了，再读入内存，提高了读的效率。
            BufferedReader br = new BufferedReader(read);
            String txt = null;
            // 读取文件，将文件内容放入到set中
            while ((txt = br.readLine()) != null) {
                wordSet.add(txt);
            }
            br.close();
            // 关闭文件流
            read.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return wordSet;
    }
    // 将HashSet中的敏感词,存入HashMap中
    private Map addSensitiveWordToHashMap(Set<String> wordSet) {
    // 初始化敏感词容器，减少扩容操作
    Map wordMap = new HashMap(wordSet.size());
        for (String word : wordSet) {
            Map nowMap = wordMap;
            for (int i = 0; i < word.length(); i++) {
                // 转换成char型
                char keyChar = word.charAt(i);
                // 获取
                Object tempMap = nowMap.get(keyChar);
                // 如果存在该key，直接赋值
                if (tempMap != null) {
                    nowMap = (Map) tempMap;
                }
                // 不存在则，则构建一个map，同时将isEnd设置为0，因为他不是最后一个
                else {
                    // 设置标志位
                    Map<String, String> newMap = new HashMap<String, String>();
                    newMap.put("isEnd", "0");
                    // 添加到集合
                    nowMap.put(keyChar, newMap);
                    nowMap = newMap;
                }
                // 最后一个
                if (i == word.length() - 1) {
                    nowMap.put("isEnd", "1");
                }
            }
        }
        return wordMap;
    }
}
```







## 1.3、工具类



```java
import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
 
//敏感词过滤器：利用DFA算法  进行敏感词过滤
public class SensitiveFilter {
    //敏感词过滤器：利用DFA算法  进行敏感词过滤
    private Map sensitiveWordMap = null;
 
    // 最小匹配规则
    public static int minMatchType = 1;
 
    // 最大匹配规则
    public static int maxMatchType = 2;
 
    // 单例
    private static SensitiveFilter instance = null;
 
    // 构造函数，初始化敏感词库
    private SensitiveFilter() throws IOException {
        sensitiveWordMap = new SensitiveWordInit().initKeyWord();
    }
 
    // 获取单例
    public static SensitiveFilter getInstance() throws IOException {
        if (null == instance) {
            instance = new SensitiveFilter();
        }
        return instance;
    }
 
    // 获取文字中的敏感词
    public Set<String> getSensitiveWord(String txt, int matchType) {
        Set<String> sensitiveWordList = new HashSet<String>();
        for (int i = 0; i < txt.length(); i++) {
            // 判断是否包含敏感字符
            int length = CheckSensitiveWord(txt, i, matchType);
            // 存在,加入list中
            if (length > 0) {
                sensitiveWordList.add(txt.substring(i, i + length));
                // 减1的原因，是因为for会自增
                i = i + length - 1;
            }
        }
        return sensitiveWordList;
    }
    // 替换敏感字字符
    public String replaceSensitiveWord(String txt, int matchType,
                                       String replaceChar) {
        String resultTxt = txt;
        // 获取所有的敏感词
        Set<String> set = getSensitiveWord(txt, matchType);
        Iterator<String> iterator = set.iterator();
        String word = null;
        String replaceString = null;
        while (iterator.hasNext()) {
            word = iterator.next();
            replaceString = getReplaceChars(replaceChar, word.length());
            resultTxt = resultTxt.replaceAll(word, replaceString);
        }
        return resultTxt;
    }
 
    /**
     * 获取替换字符串
     *
     * @param replaceChar
     * @param length
     * @return
     */
    private String getReplaceChars(String replaceChar, int length) {
        String resultReplace = replaceChar;
        for (int i = 1; i < length; i++) {
            resultReplace += replaceChar;
        }
        return resultReplace;
    }
 
    /**
     * 检查文字中是否包含敏感字符，检查规则如下：<br>
     * 如果存在，则返回敏感词字符的长度，不存在返回0
     * @param txt
     * @param beginIndex
     * @param matchType
     * @return
     */
    public int CheckSensitiveWord(String txt, int beginIndex, int matchType) {
        // 敏感词结束标识位：用于敏感词只有1位的情况
        boolean flag = false;
        // 匹配标识数默认为0
        int matchFlag = 0;
        Map nowMap = sensitiveWordMap;
        for (int i = beginIndex; i < txt.length(); i++) {
            char word = txt.charAt(i);
            // 获取指定key
            nowMap = (Map) nowMap.get(word);
            // 存在，则判断是否为最后一个
            if (nowMap != null) {
                // 找到相应key，匹配标识+1
                matchFlag++;
                // 如果为最后一个匹配规则,结束循环，返回匹配标识数
                if ("1".equals(nowMap.get("isEnd"))) {
                    // 结束标志位为true
                    flag = true;
                    // 最小规则，直接返回,最大规则还需继续查找
                    if (SensitiveFilter.minMatchType == matchType) {
                        break;
                    }
                }
            }
            // 不存在，直接返回
            else {
                break;
            }
        }
 
        if (SensitiveFilter.maxMatchType == matchType){
            if(matchFlag < 2 || !flag){        //长度必须大于等于1，为词
                matchFlag = 0;
            }
        }
        if (SensitiveFilter.minMatchType == matchType){
            if(matchFlag < 2 && !flag){        //长度必须大于等于1，为词
                matchFlag = 0;
            }
        }
        return matchFlag;
    }
}
```





## 1.4、控制层



```java
//非法敏感词汇判断
SensitiveFilter filter = SensitiveFilter.getInstance();
int n = filter.CheckSensitiveWord(searchkey,0,1);
if(n > 0){ //存在非法字符
    logger.info("这个人输入了非法字符--> {},不知道他到底要查什么~ userid--> {}",searchkey,userid);
    return null;
}
```



也可将敏感文字替换`\*`等字符 ：

```java
SensitiveFilter filter = SensitiveFilter.getInstance();
String text = "敏感文字";
String x = filter.replaceSensitiveWord(text, 1, "*");
```







# 2、订单系统





本文主要讲述了在传统电商企业中，订单系统应承载的角色，就订单系统所包含的主要功能模块梳理了设计思路，并对订单系统未来的发展做了一些思考。



## 1.1、订单系统在企业中的角色

在搭建企业订单系统之前，需要先梳理企业整体业务系统之间的关系和订单系统上下游关系，只有划分清业务系统边界，才能确定订单系统的职责与功能，进而保证各系统之间高效简洁的工作。



## 1.2、 订单系统与各业务系统的关系



<img src="https://cyw-imgbed.oss-cn-hangzhou.aliyuncs.com/img/image-20220729083713975.png"/>



**（1）对外系统：**

所有给企业外部用户使用的系统都在这一层，包括官网、普通用户使用的C端，还包括给商户使用的商家后台和在各个销售渠道进行分销的系统，比如与银行信用卡中心合作、微信合作在合作商的平台露出本企业的产品。这类系统站在与客户接触的最前线，是公司实现商业模式的桥头堡。

**（2）管理中后台：**

每个C端的业务形态都会有一个对应的系统模块，如负责管理平台交易的订单系统，管理优惠信息的促销系统，管理平台所有产品的产品系统，以及管理所有对外系统显示内容的内容系统等。

**（3）公共服务系统：**

随着企业的发展，信息化建设到达一定程度后，企业需要将通用功能服务化、平台化，以保证应用架构的合理性，提升服务效率。这类系统主要给其他应用系统提供基础服务能力支持。







## 1.3、 订单系统上下游关系



<img src="https://cyw-imgbed.oss-cn-hangzhou.aliyuncs.com/img/image-20220729083909474.png" />



**（1）订单服务**

该模块的主要功能是用户日常使用的服务和页面，主要有订单列表、订单详情、在线下单等，还包括为公共业务模块提供的多维度订单数据服务。

**（2）订单逻辑**

订单系统的核心，起着至关重要的作用，在订单系统负责管理订单创建、订单支付、订单生产、订单确认、订单完成、取消订单等订单流程。还涉及到复杂的订单状态规则、订单金额计算规则以及增减库存规则等。在4节核心功能设计中会重点来说。

**（3）底层服务**

信息化建设达到一定程度的企业，一般会将公司公共服务模块化，比如：产品，会构建对应的产品系统，代码、数据库，接口等相对独立。但是，这也带来了一个问题，比如：订单创建的场景下需要获取的信息分散在各个系统。

如果需要从各个公共服务系统调用：一是会花费大量时间，二是代码的维护成本非常高。因此，订单系统接入所需的公共服务模块接口，在订单系统即可完成对接公共系统的服务。



## 1.4、订单系统核心功能





### 1.4.1、内容

<img src="https://cyw-imgbed.oss-cn-hangzhou.aliyuncs.com/img/image-20220729084030441.png"/>



为了使订单系统能够对订单进行高效、精准的管理和跟踪，订单会储存关于产品、优惠、用户、支付信息等一系列的订单实时数据，来和下游系统，如：促销、仓储、物流进行交互。

以一个通用B2C商城的订单为例，梳理其包含的信息如下：

这里要注意的是订单类型，随着平台业务的不断发展，品类丰富、交易方式丰富后，需要对订单进行多维度的分类管理，同时订单类型利于订单系统的扩展性。每种订单类型将会对应一套流程及一套状态，便于对订单进行分类管理和复用。



### 1.4.2、流程



流程是指从平台角度出发，将订单从创建到完成的整个流转过程进行抽象，从而形成了一套标准流程规则。而不同的产品类型或交易类型在系统中的流程会千差万别，因此为了方便对订单流程进行管理，会组建流程引擎模块。

每套订单流程中会包含正向流程及逆向流程，正向流程可以比作一次顺利的网购体验过程中，后台系统之间的信息流转。逆向流程则是修改订单、取消订单、退款、退货等各种动作引起的后台系统流程，同时每个流程触发的条件又可分为系统触发和人工触发两种场景。

**（1）正向流程**

以一个通用B2C商城的订单系统为例，根据其实际业务场景，其订单流程可抽象为5大步骤：**订单创建>订单支付>订单生产>订单确认>订单完成。**

而每个步骤的背后，订单是如何在多系统之间交互流转的，可概括如下图：

<img src="https://cyw-imgbed.oss-cn-hangzhou.aliyuncs.com/img/image-20220729084307331.png" />



**订单创建：**

用户下单后，系统需要生成订单，此时需要先获取下单中涉及的商品信息，然后获取该商品所涉及到的优惠信息，如果商品不参与优惠信息，则无此环节。

接着获取该账户的会员权益，这里要注意的是：优惠信息与会员权益的区别，比如：商品满减是优惠信息，SUPER会员全场9.8折指的是会员权益，一个是针对商品，另一个是针对账户。其次就是优惠活动的叠加规则和优先级规则等。

增减库存规则是指订单中的商品，何时从仓储系统中对相应商品库存进行扣除，目前主流有两种方式：

**下单减库存——即用户下单成功时减少库存数量**

- **优势**：用户体验友好，系统逻辑简洁；
- **缺点**：会导致恶意下单或下单后却不买，使得真正有需求的用户无法购买，影响真实销量；

**解决办法：**

1. 设置订单有效时间，若订单创建成功N分钟不付款，则订单取消，库存回滚；
2. 限购，用各种条件来限制买家的购买件数，比如一个账号、一个ip，只能买一件；
3. 风控，从技术角度进行判断，屏蔽恶意账号，禁止恶意账号购买。

**付款减库存——即用户支付完成并反馈给平台后再减少库存数量**

- **优势**：减少无效订单带来的资源损耗；
- **缺点**：因第三方支付返回结果存在时差，同一时间多个用户同时付款成功，会导致下单数目超过库存，商家库存不足容易引发断货和投诉，成本增加。

**解决办法：**

1. 付款前再次校验库存，如确认订单要付款时再验证一次，并友好提示用户库存不足；
2. 增加提示信息：在商品详情页，订单步骤页面提示不及时付款，不能保证有库存等。

综上所述，两种方式各有优缺点，因此，需结合实际场景进行考虑，如：秒杀、抢购、促销活动等，可使用下单减库存的方式。而对于产品库存量大，并发流量没有那么强的产品使用付款减库存的方式。

将两种方式带入到销售场景中，关联商品类型、促销类型、供需关系等，灵活使用，以充分发挥计算机系统的优势。



**订单支付：**

用户支付完订单后，需要获取订单的支付信息，包括支付流水号、支付时间等。支付完订单接着就是等商家发货，但在发货过程中，根据平台业务模式的不同，可能会涉及到订单的拆分。

订单拆分一般分两种：

- 一种是用户挑选的商品来自于不同渠道（自营与商家，商家与商家）；
- 另一种是在SKU层面上拆分订单：不同仓库，不同运输要求的SKU，包裹重量体积限制等因素需要将订单拆分。

订单拆分也是一个相对独立的模块，这里就不详细描述了。

**订单生产**：订单生产，是指产品从企业到用户这一流程的概述。如电商平台中，商家发货过程已有一个标准化的流程，订单内容会发送到仓库，仓库对商品进行打单、拣货、包装、交接快递进行配送。

**订单确认**：收到货后，订单系统需要在快递被签收后提醒用户对商品做评价。这里要注意，确认收到货不代表交易成功，相反是售后服务的开始。

**订单完成**：订单完成是指在收到货X天的状态，此时订单不在售后的支持时间范围内。到此，一个订单的正向流程就算走完了。





**（2）逆向流程**



<img src="https://cyw-imgbed.oss-cn-hangzhou.aliyuncs.com/img/image-20220729084418408.png" />



上面说到逆向流程是各种修改订单、取消订单、退款、退货等操作，需要梳理清楚这些流程与正向流程的关系，才能理清订单系统完整的订单流程。

**订单修改**：可梳理订单内信息，根据信息关联程度及业务诉求，设定订单的可修改范围是什么，比如：客户下单后，想修改收货人地址及电话。此时只需对相应数据进行更新即可。

**订单取消**：用户提交订单后没有进行支付操作，此时用户原则上属于取消订单，因为还未付款，则比较简单，只需要将原本提交订单时扣减的库存补回，促销优惠中使用的优惠券，权益等视平台规则，进行相应补回。

**退款**：用户支付成功后，客户发出退款的诉求后，需商户进行退款审核，双方达成一致后，系统应以退款单的形式完成退款，关联原订单数据。因商品无变化，所以不需考虑与库存系统的交互，仅需考虑促销系统及支付系统交互即可。

**退货**：用户支付成功后，客户发出退货的诉求后，需商户进行退款审核，双方达成一致后，需对库存系统进行补回，支付系统、促销系统以退款单形式完成退款。最后，在退款/退货流程中，需结合平台业务场景，考虑优惠分摊的逻辑，在发生退款/退货时，优惠该如何退回的处理规则和流程。

**（3）状态机**

状态机是管理订单状态逻辑的工具。状态机可归纳为3个要素，即现态、动作、次态。

1. **现态**：是指当前所处的状态。
2. **动作**：动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。
3. **次态**：动作满足后要迁往的新状态，“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。

状态机的设计需要结合平台实际业务场景，将状态间的切换细化成了执行了某个动作。

以一个B2C商城的订单系统举例如下：

<img src="https://cyw-imgbed.oss-cn-hangzhou.aliyuncs.com/img/image-20220729084455019.png" />



订单系统为了高效的对订单进行跟踪和管理，会对订单流程当中的关键节点，抽象出订单状态。而订单状态从不同用户的角度可分为，系统订单状态、商家订单状态、买家订单状态等。

对于订单系统来说，订单状态细分的颗粒度越细、越明确，订单系统管理的精度和可靠性就越高，比如：在待付款和待发货两个状态中，订单系统后台会细分为订单超时取消、订单支付失败、订单付款完成等。

因此，订单状态模块中，通常会维护状态映射表，以不同的用户角色对系统订单状态进行重新划分，以满足不同用户的需求。

除此以外，随着电商平台的不断发展，不同的业务类型，所对应的订单状态都会有所区别。所以，订单系统中一般会储存多套状态机，以满足不同的订单类型来使用。







# 3、SpringBoot+Redis 接口限流



## 3.1、搭建环境



添加依赖：

```java
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-redis</artifactId>
   <version>2.1.4.RELEASE</version>
</dependency>
```



## 3.2、自定义限流注解



```java
@Retention(RUNTIME)
@Target(METHOD)
public @interface AccessLimit { 
    int seconds();
    int maxCount();
}
```





## 3.3、自定义RedisService接口



```java
public interface  RedisService {
 
    /**
     * set存数据
     * @param key
     * @param value
     * @return
     */
    boolean set(String key, String value);
 
    /**
     * get获取数据
     * @param key
     * @return
     */
    String get(String key);
 
    /**
     * 设置有效天数
     * @param key
     * @param expire
     * @return
     */
    boolean expire(String key, long expire);
 
    /**
     * 移除数据
     * @param key
     * @return
     */
    boolean remove(String key);
 
    /**
     * 获取自增1后的 值
     * @param key
     * @param time
     * @return
     */
    Long incr(String key,long time);
}
```



## 3.4、RedisService 接口的实现类



```java
redisservice的实现类

@Service("redisService")
public class RedisServiceImpl implements RedisService {
    @Resource
    private RedisTemplate<String, ?> redisTemplate; 
 
    @Override
    public boolean set(final String key, final String value) {
        boolean result = redisTemplate.execute(new RedisCallback<Boolean>() {
            @Override
            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {
                RedisSerializer<String> serializer = redisTemplate.getStringSerializer();
                connection.set(serializer.serialize(key), serializer.serialize(value));
                return true;
            }
        });
        return result;
    }
 
    @Override
    public String get(final String key) {
        String result = redisTemplate.execute(new RedisCallback<String>() {
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException {
                RedisSerializer<String> serializer = redisTemplate.getStringSerializer();
                byte[] value = connection.get(serializer.serialize(key));
                return serializer.deserialize(value);
            }
        });
        return result;
    }
 
    @Override
    public boolean expire(final String key, long expire) {
        return redisTemplate.expire(key, expire, TimeUnit.SECONDS);
    }
 
    @Override
    public boolean remove(final String key) {
        boolean result = redisTemplate.execute(new RedisCallback<Boolean>() {
            @Override
            public Boolean doInRedis(RedisConnection connection) throws DataAccessException {
                RedisSerializer<String> serializer = redisTemplate.getStringSerializer();
                connection.del(key.getBytes());
                return true;
            }
        });
        return result;
    }
    @Override
    public Long incr(String key,long time){
        long count = redisTemplate.opsForValue().increment(key, 1);
        if (count == 1) {
            //设置有效期一分钟
            set(key,"1");
            redisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
        return count;
    }
}
```







## 3.5、自定义拦截器



```java
@Configuration
public class MyInterceptor implements HandlerInterceptor{
    
     @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception {
        //如果请求输入方法
        if (handler instanceof HandlerMethod) {
            HandlerMethod hm = (HandlerMethod) handler;
            //获取方法中的注解,看是否有该注解
            AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);
            if (accessLimit != null) {
                long seconds = accessLimit.seconds();
                int maxCount = accessLimit.maxCount();
//关于key的生成规则可以自己定义 本项目需求是对每个方法都加上限流功能，如果你只是针对ip地址限流，那么key只需要只用ip就好
                String key =     SystemUtil.getClientIp(httpServletRequest)+hm.getMethod().getName();
              
                //从redis中获取用户访问的次数
                try {
                    long q = redisService.incr(key, seconds);//此操作代表获取该key对应的值自增1后的结果
                    if (q > maxCount) {
                        //加1
                        render(httpServletResponse, new ResponseMsg(0, "请求过于频繁，请稍候再试", null)); //这里的CodeMsg是一个返回参数
                        return false;
                    }
                    return true;
                }catch (RedisConnectionFailureException e){
                    logger.info("redis错误"+e.getMessage().toString());
                    return true;
                }
            }
        }
        return false;
    }
 
    private void render(HttpServletResponse response, ResponseMsg cm) throws Exception {
        response.setContentType("application/json;charset=UTF-8");
        OutputStream out = response.getOutputStream();
        String str = new Gson().toJson(cm);
        out.write(str.getBytes("UTF-8"));
        out.flush();
        out.close();
    }
    
}
```





## 3.6、使用限流的注解



在需要限流的Controller方法中，加上自定义的限流注解即可:

```java
public class HelloController{
    // 使用限流注解
    @AccessLimit(seconds=second, maxCount=maxCount)
    @GetMapping("/hello")
    public MyRst hello(){
        return MyRst("请求成功！");
    }    
}
```











