---
title: 设计模式
tag: 设计模式
categories:
  - [后端,Java]
  - [后端,设计模式]

---

<h1>设计模式</h1>

[toc]

# 零、资料



> - [软件设计-七大原则-CSDN博客](https://blog.csdn.net/lixg88888888/article/details/78932142)
> - [设计模式 - 廖雪峰的官方网站)](https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528)
>
> 





# 一、创建型



## 1、单例模式



单例模式（Singleton）是一种非常简单且容易理解的设计模式。

顾名思义，单例即**单一的实例**，确切地讲就是指在某个系统中只存在一个实例，同时提供集中、统一的访问接口，以使系统行为保持协调一致。





### 1.1、饿汉式



<font style="color:red;font-size:1.2em;">注意事项：</font>

> - `private`单例类的无参构造器。
> - **单例类**的内部定义一个单例类类型的**静态常量**作为成员变量。
> - 提供一个`public`的静态获取单例的方法。



```java
public class HungrySingletonTest {

    public static void main(String[] args) {
        
        HungrySingleton instance1 = HungrySingleton.getInstance();
        HungrySingleton instance2 = HungrySingleton.getInstance();
        System.out.println(instance1==instance2); // true
        
    }
}

// ----------------------------------

class HungrySingleton {
    // (2)
    private static final HungrySingleton singleton = new HungrySingleton();

    // (1)
    private HungrySingleton() {}

    // (3)
    public static HungrySingleton getInstance(){
        return singleton;
    }
    
}

```





### 1.2、懒汉式



<font style="color:red;font-size:1.2em;">注意事项：</font>

> - `private`无参构造器
> - **单例类**的内部定义一个单例类类型的**静态**成员变量,并且使用`volatile`关键字来修饰，保证多线程时给成员变量的**同步性、唯一性**。
> - 提供一个`public`的静态获取单例的方法。该方法内需要**先判断实例是否为空**，若不为空，则直接返回；若为空，则对该实例的Class对象加锁，加锁后如果仍然为空，则new一个实例。



```java
public class LazySingletonTest {

    public static void main(String[] args) {
        LazySingleton instance1 = LazySingleton.getInstance();
        LazySingleton instance2 = LazySingleton.getInstance();
        System.out.println(instance1 == instance2); // true
    }
}

class LazySingleton{
    // (2)
    private volatile static LazySingleton singleton;

    // (1)
    private LazySingleton() {}    

    // (3)
    public static LazySingleton getInstance(){
		// 双检锁
        if (singleton==null){
            synchronized (LazySingleton.class){
                if (singleton==null){
                    singleton = new LazySingleton();
                }
            }
        }

        return singleton;
    }
}
```



---



## 2、工厂方法模式



一个工厂，生产多种产品。



<font style="color:red;font-size:1.2em;">步骤：</font>

> - 产品接口
> - 产品接口的实现类
> - 工厂



（1）产品接口-Car：

```java
public interface Car {
    public void driver();
}
```

（2-1）产品实现类-BMWCar：

```java
public class BMWCar implements Car{
    @Override
    public void driver() {
        System.out.println("BMWCar。。。。驾驶");
    }
}
```

（2-2）产品实现类-AudiCar：

```java
public class AudiCar implements Car{
    @Override
    public void driver() {
        System.out.println("AudiCar。。。。驾驶");
    }
}
```

（3）工厂：

```java
public class CarFactory2 {
    // 根据传入的品牌名，创建不同的产品
    public static Car produceCar(String brand){
        
        Car car = null;
        
        switch(brand){
            case "bmw":{
                car =  new BMWCar();
                break;
            }
            case "audi":{
                car =  new AudiCar();
                break;
            }         
        }
        
        return car;
    }
    
}


```

（4）调用：

```java
public class Test {
    public static void main(String[] args) {

        Car car1 = CarFactory2.produceCar("bmw");
        Car car2 = CarFactory2.produceCar("audi");
        car1.driver();
        car2.driver();
    }
}

```







<font style="color:red;font-size:1.2em;">静态工厂方法:</font>

```java
public class CarFactory2 {
    // 根据传入的品牌名，创建不同的产品
    public static Car produceCar(String brand){
        
        Car car = null;
        
        switch(brand){
            case "bmw":{
                car =  new BMWCar();
                break;
            }
            case "audi":{
                car =  new AudiCar();
                break;
            }
            default:{
                car = new BydCar();
                break;
            }
        }
        
        return car;
    }
    
}

```



---



## 3、抽象工厂模式



多个工厂，生产多种产品。



<font style="color:red;font-size:1.2em;">四个主要的涉及的代码：</font>

> - 工厂接口
> - 工厂接口的实现类
> - 产品接口
> - 产品接口的实现类



<font style="color:red;font-size:1.2em;">步骤：</font>

> - 产品接口，**定义**产品接口的抽象方法
> - 产品接口的实现类，**实现**产品接口的抽象方法
> - 工厂接口，**定义**工厂接口（用于生产产品）的抽象方法
> - 工厂接口的实现类，**实现**工厂（用于生产产品）的抽象方法
> - 工厂接口，**new** 一个实现类，赋值给一个`static`的**工厂类型**的成员变量
> - 工厂接口，编写一个`static`的**提供工厂实现类**的方法。



（1）产品接口：

```java
public interface Car {
    public void driver();
}
```

（2）产品实现类：

```java
public class BMWCar implements Car{
    @Override
    public void driver() {
        System.out.println("BMWCar。。。。驾驶");
    }
}
```

（3）工厂接口：

```java
//先工厂接口，再实现类，再继续工厂接口
public interface CarFactory {
    
    // (1)
    public Car produceCar();
    
    // (3)
    public static CarFactory factory = new CarFactoryImpl();

    // (4)
    public static CarFactory getFactory(){
        return factory;
    }

}
```

（4）工厂实现类：

```java
public class CarFactoryImpl implements CarFactory{
    // (2)
    @Override
    public Car produceCar() {
        return new BMWCar();
    }
}
```



---



## 4、原型模式



原型模式，即`Prototype`，是指创建新对象的时候，根据现有的一个类来创建。



<font style="color:red;font-size:1.2em;">步骤：</font>

> - 实现`Cloneable接口`，重写`Object`类的 `clone()` 方法。
> - **复制**数据，**返回** 对象。
> - **获取并强转**新对象。



初始版本：(缺点：获取新的对象后，需要强转数据类型)

```java
public class Student implements Cloneable {
    private int id;
    private String name;
    private int score;

    // 复制新对象并返回:
    public Object clone() {
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    }
}
```



优化版本：（直接定义一个复制方法）

```java
public class Student {
    private int id;
    private String name;
    private int score;

    public Student copy() {
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    }
}
```



---



## 5、生成器模式



生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。

​	

```java
// 此处案例使用了链式编程，链式编程就是函数的返回值是调用方法的那个对象，因此可以一直调用方法

	String url = URLBuilder.builder() // 创建Builder
        .setDomain("www.liaoxuefeng.com") // 设置domain
        .setScheme("https") // 设置scheme
        .setPath("/") // 设置路径
        .setQuery(Map.of("a", "123", "q", "K&R")) // 设置query
        .build(); // 完成build
```



---



# 二、结构型















# 三、行为型









